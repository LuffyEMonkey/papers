This document is the Korean translation of [Paxos made simple](https://lamport.azurewebsites.net/pubs/paxos-simple.pdf), translated by BlockchainOS DevTeam. 

We give thanks to author, [Leslie lamport](https://en.wikipedia.org/wiki/Leslie_Lamport)  for the permission of the translation of this paper.
____

# 서론 

고장없이 작동하는 분산시스템 구현을 위한 팍소스 알고리즘(Paxos algorithm)은 이해하기 힘든 난해한 개념으로 간주되고 있는데 그 이유는 아마도 그리스어로 처음 발표되었기 때문이라고 추측된다[5]. 팍소스 알고리즘은 실제로는 가장 단순하고도 명확한 분산 알고리즘 중 하나이다. 컨센서스(consensus) 알고리즘의 핵심은 시노드(synod) 알고리즘이다[5]. 본 논문은 먼저 컨센서스 알고리즘이 대체로 우리가 원하는 속성을 따르고 있음을 설명한 후, 마지막 부분에서 분산시스템 구축을 위한 상태머신(state machine) 접근방법에 직접 컨센서스를 적용하여 구현한 완벽한 형태의 팍소스 알고리즘을 다룬다. 이는 분산시스템 이론과 관련하여 가장 많이 인용되는 논문에서 다루고 있는 주제이므로 이미 익숙한 접근방법이라고 할 수 있다[4].

# 컨센서스 알고리즘 

## 문제

값을 제안할 수 있는 일련의 프로세스 집합이 있으며, 컨센서스 알고리즘으로 선택된 값들 중 하나의 값을 선택하도록 합의 했다고 가정하자.
또한 제한된 값이 존재하지 않을 경우 그 어떠한 값도 선택될 수 없으며, 값이 선택된 경우 프로세스는 선택값을 인지하게 된다. 컨센서스에 대한 안전성 요건은 다음과 같다:

- 제안된 값 중 단 하나의 값이 선택될 수 있다.
- 단 하나의 값만이 선택되며,
- 프로세스는 선택된 값만을 인지해야 한다.

여기서는 구체적인 활성화 요건을 다루지 않기로 한다. 다만, 제안된 값들 중에서 값이 선택되며, 하나의 값이 선택되면 프로세스가 그 값을 인지하게 된다는 점에 집중하기로 한다.
컨센서스 알고리즘에서는 Proposer, Acceptor, 및 Learner(learners)라는 세 개의 에이전트가 각자의 역할을 수행한다. 알고리즘 구현 시 단일 프로세스는 한가지 이상의 역할을 할 수 있으나, 에이전트와 프로세스간 매핑은 여기서 다루지 않기로 한다.에이전트는 메시지를 전달하며 서로 통신을 주고받는다고 가정하며, 비잔틴(Byzantine) 모델이 아닌 다음과 같은 비동기 방식을 적용한다:

- 에이전트는 임의 속도로 움직이며 작동이 중단된 경우 재기동이 가능하다. 값이 선택된 후 모든 에이전트의 움직임이 중단되면 재기동이 가능하므로, 전달 실패 후 재기동된 에이전트가 일부 정보를 기억하면 솔루션이 만들어질 수 있다. 
- 메시지의 전송이 지연되거나, 메시지가 중복되거나 손실될 수 있지만 변조되지는 않는다.

## 값의 선택

값을 설정할 수 있는 가장 쉬운 방법은 단일 Acceptor를 갖는 것이다. Proposer는 Acceptor에게 제안을 전달하고, Acceptor는 전달받은 최초의 제안 값을 선택한다. 단순하게 보일 수도 있지만 Acceptor가 메시지 수신에 실패한다면 더 이상의 진전이 어렵기 때문에 불완전하다고 할 수 있다.
값을 선택할 수 있는 또다른 방법으로 단일 Acceptor가 아닌 복수 Acceptor를 설정하기로 한다. 하나의 Proposer가 복수의 Acceptor들에게 제안값을 전달하고 Acceptor는 제안값을 수용할 수 있다. 해당 값은 충분히 많은 수의 Acceptor가 수용했을 때에 선택된다.
그렇다면 충분이 많다는 의미는 무엇일까?
과반수(majority)의 에이전트가 단일한 값을 선택했을 때에만 그 값이 선택된다고 가정한다. 두 과반집단이 최소한 하나의 Acceptor를 공통으로 보유하고 있으므로, Acceptor가 많아야(at most) 하나의 값을 수용했을 때에만 작동이 가능하다 ([3]을 위시로 수많은 논문에서 과반수를 일반화하는 경향이 보이고 있다).

단일한 Proposer가 전달실패나 메시지 손실없이 하나의 값만을 제안하더라도 값이 선택될 수 있도록 하기 위해서는 다음의 요건이 충족되어야 한다:

 >P1. Acceptor는 반드시 수신한 첫번째 제안을 수락해야 한다.

그러나 여기에는 한 가지 문제가 발생한다. 다수 Proposer가 동시에 여러 가지 다른 값을 제안하고, 모든 Acceptor가 한 가지 값을 수락했으나 다수결을 통해 단일한 값을 선택할 수 없는 경우가 발생한다. 단 2개의 값이 제안되더라도 정확히 반수의 Acceptor들이 수락을 나누어 갖는다면, 이 중 어떠한 값이 선택되었는지 인지가 불가능해 진다.P1과 과반수의 Acceptor가 수락한 경우에만 값이 선택된다는 요건은 Acceptor가 한 가지 이상의 제안을 수락하도록 허용해야 한다는 의미이다. Acceptor가 각 제안에 (자연)수를 할당하여 수락하고, 이러한 제안이 번호와 값으로 구성되도록 만들 수 있다. 혼돈을 피하고자 제안마다 다른 번호가 부여되었다고 가정한다. 그 달성방법은 구현상의 문제이므로 여기서는 가정에 국한하기로 한다.하나의 값은 단일한 제안이 과반수의 Acceptor로부터 수락되었을 때 선택된다. 이러한 경우 해당 제안(과 그 값이) 선택된 것으로 간주한다.복수의 제안이 선택되도록 설정할 수도 있지만 이러한 경우에는 선택된 모든 제안들이 모두 동일한 값을 지녀야 한다. 제안 번호에 대한 귀납으로 다음을 유추할 수 있다:

>P2. 값이 v인 제안이 선택된다면 이후에 선택된 더 높은 번호를 부여 받은 모든 제안의 값은 v이다.

번호는 순차적으로 부여되기 때문에 P2 조건은 단 하나의 값만 선택된다는 결정적인 안전성 속성을 보장한다.하나의 제안이 선택되기 위해서는 적어도 하나의 Acceptor로부터 수락 받아야 한다. 따라서 다음의 충분조건을 통해 P2를 만족시킬 수 있다:

>>P2a . 값이 v인 제안이 선택된다면 모든 Acceptor가 수락한 더 높은 번호를 부여 받은 모든 제안의 값은 v이다.

어떠한 제안이 선택되도록 하기위해서는 여전히 P1이 유효해야 한다. 비동기식 소통이 이루어지므로, 일부 특정 Acceptor c가 어떠한 제안도 전달받지 못한 상태에서 제안이 선택될 수 있기 때문이다. 가령, 신규 Proposer가 나타나 다른 값으로 높은 번호를 부여 받은 제안을 발했다고 가정해 보자. P1은 c에게 P2a에 반한 이 같은 제안을 수용하도록 요청한다. P1과 P2a를 모두 충족시키기 위해서는 다음과 같이 P2a 요건을 강화해야 한다:

>>P2b . 값이 v인 제안이 선택된다면 모든 Proposer가 발행한 높은 번호를 부여 받은 제안의 값은 모두 v이다.

Acceptor 어떠한 제안을 수락하기 위해서는 먼저 Proposer가 제안을 발행해야 하므로, P2b는 P2a를, 그리고 P2를 암시한다. P2b를 충족시키기 위해 이를 입증할 수 있는 방법을 모색해보기로 한다. 일련번호가 m이고, 값이 v인 제안이 선택되고 번호 n > m인 모든 제안의 값은 v라고 가정한다. n에 대해 귀납법을 적용하여 쉽게 이를 입증할 수 있다. 즉, 일렬번호 m : : (n ¡ 1) 으로 발행된 모든 제안의 값은 v라는 가정하에 번호가 n인 제안은 값은 v임이 입증된다. 여기서 i : : j 는 i에서 j에 이르는 번호를 의미한다. 따라서 m라는 번호가 부여된 제안이 선택된 경우, 과반수의 Acceptor 집합 c가 존재한다. 여기에 귀납법을 추가 적용하여 m이 선택되었다는 것은 다음을 의미한다.:

C에 속한 모든 Acceptor는 번호가 m : : (n ¡ 1)인 제안을 수락하고, Acceptor가 수락한 번호가 m : : (n ¡ 1)인 모든 제안의 값은 v이다.
과반수의 Acceptor 집합 s는 적어도 c 구성원 중 한 명을 포함하므로, 다음과 같은 불변성을 유지하면서 일련번호 n인 제안의 값은 v로 결론지을 수 있다.

>>P2c. 일련번호가 n이고, 값이 v인 제안이 발행된 경우, 다음과 같은 과반수의 Acceptor 집합 S가 존재한다.

- (가)S에 속하는 어떤 Acceptor도 n보다 작은 일련번호의 제안을 수락한적이 없거나, 
- (나) S에 속하는 Acceptor가 수락한 일련번호가 n보다 작은 모든 제안들 중 가장 큰 일련번호를 가진 제안의 값은 v이다.

따라서 P2c 불변성을 유지하면서 P2b를 충족시킬 수 있다.P2c를 만족시키기 위해 n번째 제안을 하려는 Proposer는 n보다 작은 일련번호의 제안들 중 다수 Acceptor 집합에 의해 수락되었거나 수락될 가장 높은 숫자의 제안을 알아내야 한다. 이미 수락된 제안은 쉽게 알아낼 수 있지만, 향후 수락을 예측하기는 어렵다. 미래를 예측하는 대신 Proposer는 이러한 수락이 발생하지 않도록 하여 통제할 수 있다.

다시 말해, Proposer는 Acceptor에게 n보다 작은 수를 지닌 제안은 더 이상 수용하지 않도록 요청한다. 이를 통해 제안 발행에 대한 다음의 알고리즘이 도출된다. 다시 말해, Proposer는 Acceptor들에게 n보다 작은 제안을 더 이상 수락하지 않도록 요청할 수 있다.

1. Proposer는 새로운 일련번호 n을 선택하고 Acceptor 집합의 모든 Acceptor에게 다음과 같이 응답하도록 요청한다:
    - (가) n보다 작은 제안을 수락하지 않을 것을 약속, 그리고
    - (나) 현재까지 수락했던 제안들 중 n보다 작지만 가장 큰 일련번호를 가진 제안.
    이를 일련번호 n에 대한 준비요청이라 부르기로 한다.

2. Proposer가 다수의 응답자로부터 요청한 응답을 받은 경우, 값이 v인 n번째 제안을 발행할 수 있다. 이때 v는 응답으로 돌아온 가장 큰 일련번호의 제안의 값이거나, 이러한 제안이 존재하지 않는 다면 Proposer가 선택한 값을 의미한다.

Proposer는 특정 집단의 Acceptor에게 제안 수락을 요청하며 제안을 발행한다(이는 최초 요청에 응답한 Acceptor 집단과 동일하지 않아도 된다). 이를 수락요청으로 부르기로 한다. 이는 Proposer의 알고리즘을 설명하고 있다. Acceptor의 경우는 어떠 한가? Acceptor는 Proposer로부터 준비요청과 수락요청이라는 두 가지 요청을 전달받을 수 있다. Acceptor는 안전성을 저해 받지 않은 채 요청을 무시할 수 있다. 

따라서 Acceptor의 요청에 대한 응답이 수락된 경우만을 논하기로 한다. Acceptor는 언제나 준비요청에 응답할 수 있으며, Acceptor가 약속한 경우 수락요청에 응답하여 제안을 수용할 수도 있다. 다시 말해:

>P1a . Acceptor는 n보다 큰 숫자의 준비요청에 응답하지 않은 경우에만, n번째 제안을 수락할 수 있다.

P1a가 P1을 포함하는 것을 알 수 있다.

고유의 제안 숫자를 지닌 안전성 특성에 요구되는 조건을 충족시키는 값을 선택할 수 있는 완벽한 알고리즘을 얻게 된다. 최종적인 알고리즘은 약간의 최적화를 통해 완성된다. Acceptor가 n번 준비요청을 받았지만 이미 n보다 큰 준비요청에 응답했으므로 더 이상 새로운 n번 제안을 수락하지 않기로 동의했다고 가정하자. Proposer가 발행을 원하는 n번 제안을 Acceptor가 수락하지 않을 것이므로 Acceptor는 신규 준비요청에 응답하지 않아도 된다. 따라서 Acceptor는 이러한 준비요청을 무시한다. 또한 이미 수락된 제안에 대한 준비요청을 무시하게 된다.

이러한 최적화를 통해 Acceptor는 수락한 제안 중 가장 큰 일련번호를 지닌 제안과 Acceptor가 응답한 가장 큰 일련번호의 준비요청만을 기억하게 된다. P2c가 실패여부와 관계 없이 그 불변성을 반드시 유지해야 하므로 Acceptor는 실패 후 재기동 하더라도 이러한 정보를 반드시 기억해야 한다. Proposer가 같은 일련번호로 다른 제안을 발행하려 하지 않는 한 이러한 제안을 폐기하고 이에 대한 모든 정보를 삭제한다는 사실에 유념한다.
Proposer와 Acceptor의 행위를 종합하여 해당 알고리즘이 다음과 같은 두 가지 단계로 작동한다는 사실을 알 수 있다.

- 1단계.
  - (가)Proposer는 일련번호 n을 선택하고 다수 Acceptor에게 일련번호 n의 준비요청을 전달한다.
  - (나)Acceptor가 이미 응답했던 준비요청의 일련번호보다 더 큰 일련번호 n의 준비요청을 받는다면, n보다 작은 일련번호를 지닌 제안을 수락하지 않는다는 약속과 (해당하는 경우) Acceptor가 이미 수락한 가장 큰 일련번호의 제안을 응답으로 보낸다.

- 2단계. 
  - (가) 다수 Acceptor로부터 (일련번호 n에 대한) 준비요청에 대한 응답을 받은 Proposer는 v값의 일련번호 n의 제안에 대하여 응대한 모든 Acceptor에게 수락요청을 전달한다. 이때 v는 이러한 응답 중 가장 큰 일련번호 제안의 값이거나, 이러한 응답에 어떠한 제안도 수록되어 있지 않은 경우 어떠한 값도 가능하다.
  - (나) Acceptor는 n번 제안에 대한 수락요청을 받은 후 일련번호가 n보다 큰 준비요청에 이미 응답하지 않은 경우, 이러한 제안을 수용한다.

Proposer는 각각에 대한 알고리즘을 따를 경우 복수의 제안을 발행할 수 있다. 또한 프로토콜 중 언제라도 이러한 제안을 폐기할 수 있다(요청 및/혹은 제안에 대한 응답이 해당 제안이 폐기된 후 목적지에 도달했다고 하더라도 정확성은 유지된다). Proposer가 더 큰 수의 제안을 발행하려 한다면 제안을 폐기하는 것이 바람직하다. 따라서 Acceptor가 더 큰 수로 준비요청을 이미 전달받았으므로 준비요청이나 수락요청을 무시한다면, 이를 해당 제안을 폐기해야 하는 Proposer에게 통보해야 할 것이다. 이는 정확성에 영향을 미치지 않는 성능 최적화 방안이다.

## 선택값의 인지

선택된 값을 인지하기 위해, Learner는 반드시 다수 Acceptor가 수용한 제안을 인지해야 한다. 가장 명확한 알고리즘은 각 Acceptor가 제안을 수락할 때마다 이를 모든 Learner에게 전달하는 것이다. 이를 통해 Learner는 가장 빠르게 선택값을 인지하게 되지만 그러기 위해서는 모든 Acceptor가 모든 Learner에게 반응해야 한다. 즉, 응답수가 Acceptor 수 및 Learner 수의 산물과 동일해야 한다. 비잔틴 모델에 의거하지 않은 실패에 대한 가정으로 수락 값에 대하여 인지가 다른 Learner로부터 빠르게 파악할 수 있다. Acceptor가 수용한 내용을 고유(distinguished) Learner에게 전달할 수 있으며, 이를 통해 값이 선택된 경우 이를 다른 Learner에게 통보할 수 있다. 모든 Learner가 선택값을 인지하도록 하기 위해서는 추가 활동이 필요하며, 고유 Learner 역시 전송에 실패할 수 있으므로 안전성이 떨어진다. 그러나 Acceptor 수 및 Learner 수의 총합과 동일한 응답수만이 요구된다.

더 쉽게 설명하면, Acceptor들은 특정 고유 Learner들에게만 수락한 제안을 보내고, 어떤 값이 선택될 경우에만 다른 Learner들에게 그 제안을 보내주도록 할 수 있다. 더 많은 수의 고유 Learner들을 활용할 경우 안전성은 강화되지만 소통에 있어서의 복잡성은 커지게 된다.메시지 손실로 인하여 Learner가 선택값을 파악하지 못할 가능성도 있다. Learner는 Acceptor에게 수락된 제안에 대한 정보를 요청할 수 있지만, Acceptor가 메시지 수용에 실패한 경우 해당 제안에 대해 다수의 Acceptor가 이를 수용했는지 여부에 대한 파악이 불가능하다. 이러한 경우, Learner는 신규 제안이 선택된 경우에만 선택값을 파악할 수 있다. 값이 선택되었는지 여부를 알기 위해 Learner는 위에 설명된 알고리즘으로 Proposer에게 제안을 하도록 하여 어떤 값이 선택되었는지 알아낼 수 있다.

## 진행

두 Proposer가 순차적으로 증가하는 숫자의 제안을 계속 발행하지만 어떠한 제안도 선택되지 않는 시나리오를 쉽게 만들어낼 수 있다. 

P라는 Proposer가 일련번호 n1의 제안에 대한 1단계를 완료한 후, q라는 Proposer가 숫자 n2>n1의 제안에 대한 1단계를 완료했다고 가정한다. P Proposer의 n1 제안에 대한 수락요청 2단계는 Acceptor들이 모두 n2보다 작은 수의 모든 신규 제안을 수락하지 않기로 약속했으므로 무시된다. 따라서 pProposer는 n3>n2인 신규 제안에 대한 1단계를 시작하여 완료하고, qProposer의 수락요청에 대한 두번째 2단계가 무시되도록 만든다. 이 같은 과정이 반복된다.

시나리오 진행을 위해서는 고유 Proposer만이 제안을 발행할 수 있도록 설정되어야 한다. 고유 Proposer가 이미 사용된 수보다 큰 일련번호의 제안을 선택하여 발행한다면 이러한 제안이 수락된다. 
고유 Proposer는 더 큰 수의 제안요청에 대해 인지하여 폐기와 시도를 반복한다면, 해당 Proposer는 발행에 충분한 큰 수의 제안을 선택하게 된다.

(Proposer, Acceptor, 및 통신네트워크로 구성된) 시스템이 충분히 제대로 작동한다면 단일한 고유 Proposer를 선출하는 방법으로 활성화될 수 있다. 이와 관련하여 가장 잘 알려진 피셔(Fisher), 린치(Lynch), 패터슨(Patterson)의 논문[1]은 기술적으로 신뢰할 수 있는 Proposer 선택 알고리즘이 반드시 무작위성이나 timeout 같은 실시간성을 이용해야 한다고 지적한다. 그러나 이러한 선택의 성공여부와 관계없이 안전성은 확보될 수 있다.

## 구현

팍소스 알고리즘[5]은 프로세스들로 구성된 하나의 네트워크를 가정한다. 컨센서스 알고리즘 안에서 각 프로세스는 Proposer, Acceptor, 및 Learner의 역할을 수행한다. 알고리즘에서는 리더가 선택되며, 선택된 리더는 고유의 Proposer 및 Learner의 역할을 한다. 팍소스 컨센서스 알고리즘은 요청과 응답이 일반적인 메시지로 전달되는 구조로 위의 설명과 정확하게 일치한다(응답메시지는 혼돈을 피하기 위하여 상응하는 제안번호로 표시(tagged)된다).실패가 발생하는 동안 Acceptor가 반드시 기억해야 하는 정보가 저장공간에 담기게 된다. Acceptor는 실제 응답전송 전 안정적인 저장공간에 의도한 응답을 기록한다.이제 같은 번호로 서로 다른 두 가지 제안이 발행되지 않도록 하는 메커니즘을 설명하는 일이 남아있다. 각기 다른 Proposer가 각기 다른 숫자를 선택하여 같은 숫자로 두 개의 제안이 발행되지 않도록 할 수 있다. 각 Proposer는 (안정적인 저장장소에) 발행을 시도했던 가장 큰 수의 제안을 기억하여, 이전 사용된 숫자 중 큰 수의 제안에 대해 1단계를 수행한다.

# 상태 머신의 구현

분산시스템을 가장 쉽게 구현할 수 있는 방법은 중앙서버에서 명령을 내리는 클라이언트 집단을 구성하는 것이다. 이러한 서버는 일련의 시퀀스로 클라이언트의 명령을 수행하는 결정론적 상태머신으로 설명할 수 있다. 상태머신은 현재상태를 유지한다. 명령을 입력하여 결과를 도출하고 새로운 상태에 이르는 과정을 수행한다. 가령, 분산된 은행시스템의 클라이언트가 창구직원인 경우, 상태머신의 상태는 전 고객의 계정으로 구성될 수 있다. 예금인출의 경우, 계좌잔고가 인출액보다 많다면 상태머신에 해당 계정의 잔액을 감소시키도록 명령을 내리고, 그 신/구 잔액에 결과를 표시하도록 하여 작업을 진행한다. 단일 중앙서버를 이용하여 구현한다면, 서버 고장 시 구현이 어려워진다. 따라서 서버집단을 이용하는 대신 각 서버가 독립적으로 상태머신을 구현하도록 설정한다. 상태머신이 결정론적으로 수행하므로 모든 서버가 동일 시퀀스의 명령을 수행할 경우 동일한 상태 및 결과 시퀀스를 도출하게 된다. 명령을 발행하는 클라이언트는 어떠한 서버를 이용하던 간에 같은 결과를 얻을 수 있다.

모든 서버가 동일 시퀀스의 상태머신 명령을 실행하도록 팍소스 컨센서스 알고리즘의 해당 시퀀스에서 i 번째 상태머신 명령이 되는 i번째 인스턴스가 선택한 값인 별도의 인스턴스 시퀀스를 구현하기로 한다. 해당 알고리즘의 모든 인스턴스에서 각 서버는 (Proposer, Acceptor, 및 Learner)의 역할을 수행한다. 이제 서버 구상이 마무리 되었으므로 컨센서스 알고리즘의 모든 인스턴스 들은 동일한 에이전트 집단을 사용한다고 가정한다.

단일 서버는 정상적으로 작동하는 경우 리더를 선출하고, 리더는 컨센서스 알고리즘의 모든 인스턴스에서 (유일하게 제안을 발행하는) 고유 Proposer로 작동한다. 클라이언트는 리더에게 명령을 전달하고 리더는 각 명령이 시퀀스 중 어디에 나타나야 하는지를 결정한다.

리더가 특정 클라이언트의 명령을 135번째 명령으로 결정한 경우, 해당 명령이 컨센서스 알고리즘의 135번째 인스턴스의 값으로 선택되도록 시도한다. 이러한 시도는 대부분 성공하지만 결함이나, 다른 서버가 스스로를 리더로 인식하여 135번째 명령에 다른 의견을 가짐으로 인해 실패로 돌아가기도 한다. 그러나 이러한 컨센서스 알고리즘은 최소한 하나의 명령이 135번째 명령으로 선택되도록 만들 수 있다. 팍소스 컨센서스 알고리즘의 중요한 장점은 2단계로 나누어져, 2단계가 시작되기 전까지는 값이 결정되지 않는다는 점이다.

Proposer 알고리즘의 1단계가 완료된 후, 제안된 값이 결정되거나 Proposer가 자유롭게 값을 제안할 수 있음을 떠올려보자. 정상 작동 시 팍소스 상태머신 이행과정을 설명하기로 한다. 발생할 수 있는 문제점에 대해서는 추후 논의하기로 한다. 기존 리더의 실패로 신규 리더 선출 시 발생하는 내용에 대해 다룬다(시스템 스타트 업은 아직 어떠한 명령도 제안되지 않았으므로 특별한 경우라 할 수 있다).

컨센서스 알고리즘의 모든 인스턴스의 Learner인 신규 리더는 이미 선택된 대부분의 명령을 알아야 한다. 컨센서스 알고리즘의 1-134, 138, 및 139 인스턴스에서 선택된 값인 1-134, 138, 및 139 명령에 대해 습득했다고 가정하자(명령 시퀀스의 격차가 발생하는 이유에 대해서는 추후 다루기로 한다). 다음으로 135-137 인스턴스 및 139보다 큰 모든 인스턴스의 1단계를 실행한다(그 작동원리에 대해서는 아래에서 살펴보기로 한다). 실행 결과 135 및 140 인스턴스에서 제안된 값이 결정되지만 제안값이 다른 모든 인스턴스에 한정 되지 않은 채로 남게 된다. 다음으로 135 및 140 인스턴스에 대한 2단계를 실행하여 135 및 140 명령을 선택한다. 리더와 리더가 알고 있는 모든 명령을 인지한 다른 모든 서버는 이제 1-135의 명령을 실행할 수 있게 된다. 그러나 138-140 명령을 실행이 불가능한데, 그 이유는 136과 137일 아직 선택되지 않았기 때문이다. 리더는 클라이언트의 요청대로 다음 2개의 명령이 136 및 137 명령이 되도록 만들 수 있다. 혹은 136 및 137 명령을 해당 상태를 그대로 유지하도록 하는 특수 “noop” 명령으로 제안하며 즉시 격차를 메울 수 있다(컨센서스 알고리즘의 136 및 137 인스턴스 2단계를 실행하여 달성할 수 있다). Noop 명령어가 선택되면 138-140 명령이 실행될 수 있다. 1-140 명령이 선택되었으므로 리더는 컨센서스 알고리즘에서 140보다 큰 모든 인스턴스에 대해 1단계를 완료하고 이러한 인스턴스의 2단계에서 자유롭게 값을 제안할 수 있다. 리더는 클라이언트가 요청한 다음 명령에 141 명령번호를 할당하여 컨센서스 알고리즘 141 인스턴스의 2단계 값으로 제안한다. 전달받은 클라이언트의 다음 명령을 142로 제안하고, 계속해서 이 같이 수행한다. 

리더는 141로 제안된 명령이 선택되었음을 인지하기 이전 142 명령을 제안할 수 있다. 141 명령 제안으로 전달하는 모든 메시지가 손실될 수 있으며, 리더가 141로 제안한 인스턴스가 무엇인지 다른 모든 서버가 인지하기전 142 명령이 선택될 수도 있다. 리더가 141 인스턴스에서 2단계 메시지에 대해 예상한 응답을 받지 못한 경우, 해당 메시지를 재전송한다. 제대로 작동할 경우, 제안한 명령이 선택된다. 그러나 선택된 명령어 시퀀스에 간극을 남기며 먼저 실패할 수도 있다.리더가 명령을 먼저 받을 수 있다고 가정하자. 즉 리더는 1 i 명령이 선택된 후, i+1 i+  명령을 제안할 수 있다는 의미이다. 이러한 경우, 명령에 달하는 격차가 발생할 수 있다.

신규리더는 컨센서스 알고리즘의 무한대로 많은 인스턴스에 대해 1단계를 실행할 수 있다. 위의 경우 135-137 인스턴스 및 139보다 큰 모든 인스턴스를 말한다. 모든 인스턴스에 대해 동일한 일련번호의 제안을 사용한다면, 단 하나의 단문 메시지를 모든 서버에 보내는 것으로 이를 처리할 수 있다. 1단계에서 Acceptor는 Proposer로부터 이미 2단계 메시지를 받았을 때에만 단순한 OK 이상의 응답을 보낸다(시나리오 상에서는 135 및 140 인스턴스의 경우에만 해당한다). (Acceptor로 활동하는) 서버는 모든 인스턴스에 대해 하나의 단문 메시지로 응답할 수 있다. 따라서 1단계의 무한대로 많은 인스턴스를 실행하는 데에는 아무런 문제로 발생하지 않는다.

리더의 실패 및 신규리더 선출은 극히 드물게 발생하기 때문에, 실제로 상태 머신 명령을 실행하는 즉 명령/값에 대한 컨센서스를 달성하는 실제 비용은 2단계를 실행하는 비용이다. 팍소스 컨센서스 알고리즘 2단계는 결함 발생시 합의를 도출하기 위한 최소한의 비용임을 증명할 수 있으므로[2], 팍소스 알고리즘은 본질적으로 최적이라고 할 수 있다.

시스템의 정상적인 운영에 대한 논의는 현 리더의 결함으로 인한 신규 리더 선출에 걸리는 짧은 기간을 제외하고 언제나 단일 리더를 가지고 있다고 가정한다. 비정상적인 환경에서는 리더 선출에 실패할 수도 있다. 리더의 역할을 하는 서버가 없다면 신규 명령이 제안되지 않는다. 다수의 서버가 스스로를 리더로 인지한다면 컨센서스 알고리즘의 동일 인스턴스에 대하여 모두 값을 제안할 수 있으므로, 값을 선택할 수 없게 된다.

그러나 각기 다른 두 개의 서버가 결국에는 i번째 상태머신 명령에 대하여 선택된 값에 대해 합의할 것이므로 안전성은 유지된다. 단일 리더 선출은 진행을 확보하려는 용도로만 필요하다. 서버들의 집합이 변경될 경우, 어떤 서버가 어떤 인스턴스를 구현하는지 결정하는 방법이 있어야 한다.

이러한 문제는 상태머신을 이용하여 가장 손쉽게 해결될 수 있다. 현 서버 집합이 상태의 일부로 구성되어 일반적인 상태머신 명령으로 변경되도록 할 수 있다. i +  인스턴스 컨센서스 알고리즘을 실행하는 서버 집합이 i 번째 상태머신 명령을 실행 직후의 상태로 정하면 리더가  명령을 미리 실행하도록 만들 수 있다. 이를 통해 임의적으로 정교하게 재구성된 알고리즘을 손쉽게 구현할 수 있게 된다.

# 참고문헌

- [1] Michael J. Fischer, Nancy Lynch, and Michael S. Paterson. Impossibility of distributed consensus with one faulty process. Journal of the ACM, 32(2):374–382, April 1985.
- [2] Idit Keidar and Sergio Rajsbaum. On the cost of fault-tolerant consensus when there are no faults—a tutorial. TechnicalReport MIT-LCS-TR-821, Laboratory for Computer Science, Massachusetts Institute Technology, Cambridge, MA, 02139, May 2001. also published in SIGACT News 32(2) (June 2001).
- [3] Leslie Lamport. The implementation of reliable distributed multiprocess systems. Computer Networks, 2:95–114, 1978.
- [4] Leslie Lamport. Time, clocks, and the ordering of events in a distributed system. Communications of the ACM, 21(7):558–565, July 1978.
- [5] Leslie Lamport. The part-time parliament. ACM Transactions on Computer Systems, 16(2):133–169, May 1998.